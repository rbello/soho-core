WG.TrayIcon = function (data) {	this.name = data.name;	this.data = data;	this.badgeText = null;	this.notification = null;	this.node = null;	this.initialized = false;};/** * Afficher un petit badge text * @return this */WG.TrayIcon.prototype.setBadgeText = function (text) {	// Delete	if (!text) {		if (this.badgeText) {			$(this.badgeText).remove();			this.badgeText = null;		}		return this;	}	// Set	if (!this.badgeText) {		this.badgeText = document.createElement('span');		this.badgeText.setAttribute('class', 'badge');		this.node.appendChild(this.badgeText);		// Propager un clic sur le badge text au lien de l'icone		var thiz = this;		this.badgeText.onclick = function () {			$(thiz.a).click();		};	}	this.badgeText.innerHTML = text;	return this;};WG.TrayIcon.prototype.setLoadingIndicator = function (enable) {	if (enable) {		$(this.node).addClass('loading');	}	else {		$(this.node).removeClass('loading');	}}/** * @return string|null */WG.TrayIcon.prototype.getBadgeText = function (text) {	return (this.badgeText) ? this.badgeText.innerHTML : null;};/** * @return this */WG.TrayIcon.prototype.setNotification = function (text, onClick, duration) {	var thiz = this;	// Delete	if (!text) {		if (this.notification) {			$(this.notification).stop().fadeTo(1000, 0, function () {				$(thiz.notification).remove();				thiz.notification = null;			});		}		return this;	}	// Create notification node	if (!this.notification) {		this.notification = document.createElement('div');		this.notification.setAttribute('class', 'notification');		$(this.notification).fadeTo(0, 0);		this.node.appendChild(this.notification);	}	// Bind onclick event	if (onClick) {		this.notification.onclick = onClick;	}	// 	this.notification.innerHTML = text;	// Appear animation	$(this.notification).stop().fadeTo(1000, 0.9);	// Duration	if (this.notificationThread != null) {		clearTimeout(this.notificationThread);	}	if (!duration) duration = 6000;	if (duration) {		setTimeout(function () {			thiz.setNotification(null);		}, duration);	}	return this;}WG.util.implementListenerPattern(WG.TrayIcon.prototype);/** * Cette méthode permet d'afficher toutes les icônes du tray. * Elle est appelée lors du processus d'ouverture de la session (open) * après l'authentification acceptée de la session. * * Cette méthode vérifie que la session est bien ouverte avant * d'initialiser les icônes. Si cette condition n'est pas remplie, cette * méthode ne fait rien et renvoi false. * * @return boolean * @access public */WG.ui.createTrayIcons = function () {	if (!WG.isLogged()) {		return false;	}	WG.util.each(uidata.trayIcons, function (icon) {		WG.ui.initTrayIcon(icon);	});	return true;};/** * @param WG.TrayIcon icon * @return void * @access private */WG.ui.initTrayIcon = function (icon) {	// Cette icône est déjà initialisée	if (icon.initialized) {		return;	}	// Debug mode	if (console) {		console.log('  Init TrayIcon: ' + icon.name);	}	// Create node	icon.node = document.createElement('div');	icon.node.setAttribute('id', icon.name);	icon.node.setAttribute('class', 'tray');	// Onclick event	if ('onClick' in icon.data) {		icon.onclick_substitut = icon.data.onClick;		icon.a = document.createElement('a');		icon.a.onclick = function () {			icon.onclick_substitut();		};		icon.node.appendChild(icon.a);	}	// Init node	if ('onInit' in icon.data) {		icon.onInit = icon.data.onInit;		icon.onInit();	}	// Append node	uidata.uiComponents.live.appendChild(icon.node);	// Save that this icon is now initialized	icon.initialized = true;	// Appear!	if ('onAppear' in icon.data) {		icon.onAppear = icon.data.onAppear;		icon.onAppear();	}};/** * Cette méthode permet de créer une nouvelle icône dans le system tray à partir * des données data. C'est la méthode à utiliser par les modules ou en interne * pour créer une nouvelle icône et la placer dans le tray. * * Si l'utilisateur est loggé et que la session est ouverte, l'icône est automatiquement * initialisée et affichée. * * @param object data Configuration de l'icône. * @return TrayIcon En cas de succès. * @return null Si data ne contient pas d'attribut name. * @access public */WG.ui.addTrayIcon = function (data) {	// Erreur	if (!data.name) {		alert('Error in WG.ui.addTrayIcon: icon name missing');		return null;	}	var obj;	// La TrayIcon n'existe pas	if (!(data.name in uidata.trayIcons)) {		// Création de l'icône		obj = new WG.TrayIcon(data);		// Enregistrement de l'icône		uidata.trayIcons[data.name] = obj;	}	// La TrayIcon existe déjà	else {		obj = uidata.trayIcons[data.name];	}	// Si la session est ouverte, que les composants UI ont bien été intialisés,	// et que cette icone n'a jamais été initialisée, c'est le moment de le faire.	if (WG.isLogged() && uidata.uiComponents && !obj.initialized) {		WG.ui.initTrayIcon(obj);	}	return obj;};/** * @return boolean */WG.ui.removeTrayIcon = function (name) {	// TODO !!!};/** * @return boolean */WG.ui.removeAllTrayIcons = function (name) {	// TODO !!!	if (console) {		console.log(' % TODO WG.ui.removeAllTrayIcons()');	}	// Note: il faut aussi s'occuper des icones listeners	// Il faut envoyer un signale à l'icône pour qu'elle se désactive bien	// + Propager les events onHide et onDestroy};/** * @return Object<TrayIcon> */WG.ui.getTrayIcons = function () {	return uidata.trayIcons;};/** * @return TrayIcon|null */WG.ui.getTrayIcon = function (name) {	return uidata.trayIcons.hasOwnProperty(name) ? uidata.trayIcons[name] : null;};/** * @return int */WG.ui.getTrayIconsCount = function () {	return Object.keys(uidata.trayIcons).length;};