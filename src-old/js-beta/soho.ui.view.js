/** * Classe View. */WG.View = function (name) {	// Save view name	this.name = name;	// View contents distribution model	this.dist = WG.View.DistributionModel.CACHE;	// Remember if view has been loaded yet	this.loadedTime = 0;	this.loadedUrl = null;	this.localCacheAge = 120000; // en ms	// Si la page a été déclarée dans le message de welcome, donc on a ses données.	// On va pouvoir adapter certains paramètres.	if (name in viewdata.available) {		var nfo = viewdata.available[name];		// Le modèle de distribution		if ('dist' in nfo) {			// On vérifie qu'il existe bien			if (nfo.dist in WG.View.DistributionModel) {				// Si oui on le modifie pour cette vue				this.dist = WG.View.DistributionModel[nfo.dist];			}		}		// L'age du cache		// TODO Mettre un moyen pour que l'age du cache soit spécifié par le serveur		// Utiliser les headers renvoyées par le serveur ?	}	// Create view node	this.node = document.createElement('div');	this.node.setAttribute('class', 'view fit-height');	this.node.setAttribute('id', 'view-' + name);	// Prepare XHR object	this.xhr = null;};/** * Renvoi l'URL de la vue avec les paramètres donnés. * @param Object params Un tableau associatif avec les données à envoyer. * @return string * @version 3.0.15 Utilisation d'un tableau pour la concaténation */WG.View.prototype.getURL = function (params) {	var url = [		WG.appURL,		'view.php?v=',		escape(this.name)	];	if (params instanceof Object) {		for (key in params) {			url.push('&');			url.push(escape(key));			url.push('=');			url.push(escape(params[key]));		}	}	return url.join('');};/** * Affiche la vue avec les paramètres donnés. * * @return true Si une nouvelle version de la vue a été demandée au serveur * @return false Si une version en cache a été utilisée. */WG.View.prototype.display = function (params, noCache, hash) {	// On recupère l'URL de la vue	var url = this.getURL(params);	// Debug	if (console) {		console.log('View URL: ' + url + ' (cache='+(noCache ? 'no' : 'yes')+', current='+(url != this.loadedUrl?'no':'yes')+')');	}	// On compare avec celle déjà chargée.	// Si ce n'est pas l'url chargée, on ne se pose pas de question :	// on télécharge une nouvelle version de la vue.	if (noCache || url != this.loadedUrl) {		this.download(url, hash);		return true;	}	switch (this.dist) {		// Dans le cas d'une distribution type KEEP_ALIVE, on regarde		// si la vue a déjà été chargée. Si non, on la demande au serveur.		// Si oui, on se contente d'afficher le noeud existant.		// C'est à la vue de se mettre à jour par elle même, grâce à ses		// données locales ou bien en utilisant le live service.		case WG.View.DistributionModel.KEEP_ALIVE :			if (!this.loadedUrl) {				this.download(url, hash);				return true;			}			return false;			break;		// Dans le cas d'une distribution type REFRESH, on va chercher		// une nouvelle version de la vue sur le serveur.		case WG.View.DistributionModel.REFRESH :			this.download(url, hash);			return true;			break;		// Dans le cas d'une distribution type LOCAL_CACHE, on commence		// par télécharger la vue si ça n'a jamais été fait. Si un cache		// existe, on verifie qu'il n'a pas expiré. Dans ce cas, on		// télécharge un nouvelle version de la vue.		case WG.View.DistributionModel.LOCAL_CACHE :		default :			// Cas du premier téléchargement.			if (!this.loadedUrl) {				this.download(url, hash);				return true;			}			// Verification de l'expiration du cache			else if (new Date().getTime() - this.loadedTime > this.localCacheAge) {				this.download(url, hash);				return true;			}			// Le cache est valide			return false;			break;		}}/** * Remplace le contenu actuel de la vue par une requête * au serveur. * @param string c Le contenu HTML de la vue. */WG.View.prototype.setContents = function (c) {	// Append view to wrapper	// jQuery est utilisé ici car il permet d'executer le code	// javascript qui se trouve dans la page	$(this.node).html(c);	// On force le lancement de cet event car il est utilisé	// un peu partout pour le repaint de certains elements ou bien	// l'application de certains comportements.	// Exemple: le fit-height 100%	$(window).trigger('resize');} /** * Remplace le contenu actuel de la vue par une requête * au serveur. */WG.View.prototype.download = function (url, hash) {	// Remove old URL, to detect ajax query abortion	this.loadedUrl = null;	this.node.innerHTML = '';	WG.setStatus('Loading view...', WG.status.WAIT);	if (console) {		console.log('  > GET ' + url + ' (AES=' + (WG.security.AES == null ? 'off' : 'on')+')');	}	// @todo Note: Pourquoi on n'utilise pas WG.ajax() ici ?	this.xhr = jQuery.ajax({		url: url,		context: this,		dataType: WG.security.AES != null ? 'text' : 'html',		type: 'GET',		success: function (data, textStatus, jqXHR) {			// Remove XHR object			this.xhr = null;			// This page is loaded, the url is stored			this.loadedUrl = url;			// Remember when the view has been loaded			this.loadedTime = new Date().getTime();			// AES Decrypt			if (WG.security.AES != null) {				// Update UI				WG.setStatus('Decrypting data...', WG.status.WAIT);				// Decrypt data				data = WG.security.aesDecrypt(data);			}			// Hide status indicator			WG.setStatus(null);			// Set page contents			this.setContents(data);			// Jump to selected id (hash)			if (typeof hash == 'string') {				document.location.hash = '#' + hash;			}			// Trigger event			WG.trigger('viewChanged', this.name);		},		error: function (jqXHR, textStatus, errorThrown) {			// Remove XHR object			this.xhr = null;			// Display error			WG.setStatus(				'Unable to get this view: <em>' + errorThrown + ' (' + textStatus + ')</em>',				WG.status.FAILURE,				function () {					if (this.refresh) {						this.refresh();					}					else {						WG.setStatus('<b>Fatal Error</b>: please restart using F5 on your keyboard', WG.status.FAILURE);					}				}			);		}	});};/* Surveille le redimensionnement de la fenêtre pour le comportement fit-height 100%. * @todo Déplacer cet appel vers un emplacement plus approprié * @see WG.View.applyStandardBehavior() */$(window).resize(function () {	$('.fit-height').trigger('fitheight');});/** * Attention, cette fonction doit utiliser jQuery.on() car elle ne * sera pas appelée de nouveau après l'initialisation du système. * * Il ne faut pas appeler deux fois cette méthode. Il faut l'appliquer * au container global des vues (#main) une fois pour toute. */WG.View.applyStandardBehavior = function (node) {	// Create a jQuery wrapper	$(node)	// Fix old url	// Cette partie permet de transformer les liens en durs en	// liens dynamiques asynchrones. L'avantage de cette methode,	// c'est qu'il n'est pas neccessaire de changer le code	// de la v2.0 (MIMO) pour la nouvelle version. En fait, il est	// meme recommande de ne pas se prendre la tete et de continuer	// a faire des liens en dur, plus simples a faire.	// v3.0.6: utilisation de jQuery.on()	// v3.0.15: les liens avec target=_blank ne sont plus concernés	.on('click', 'a[href]:not([target="_blank"])', function (e) {		// La fonction WG.View.handleLink() renvoi true si le lien a été		// traité de manière asynchrone. Ici, on renvoi FALSE dans ce cas		// pour que le comportement par défaut ne soit pas provoqué.		return !WG.View.handleLink(this.getAttribute('href'), e);	})	// La même chose pour les formulaires	.on('submit', 'form', function (e) {		return !WG.View.handleForms(this, e);	})	// Onglets	.on('click hover', 'ul.tabmenu li a', function (e) {		var li = this.parentNode,			menu = li.parentNode;		// Remove selected tab legend		$('li.selected', menu).removeClass('selected');		// Add selected indcator to this tab legend		$(li).addClass('selected');		// Hide all tabs		$('.tabcontent.tab-' + menu.getAttribute('tab'), node).removeClass('selected');		// Show the new tab		$('.tabcontent' + this.getAttribute('href'), node).addClass('selected');		// Prevent default behavior		e.preventDefault();		return false;	})	// Auto-height 100%	// L'objectif de ce code est de permettre à des composants HTML de type	// block de prendre toute la hauteur de leurs conteneurs.	.on('fitheight', '.fit-height', function () {		var t = $(this),			m = $(window).height(),			h = 0,			o = 0;		// Calcul des dimensions des bords		o =			+ parseInt(t.css('padding-top'), 10)			+ parseInt(t.css('padding-bottom'), 10)			+ parseInt(t.css('margin-top'), 10)			+ parseInt(t.css('margin-bottom'), 10)			+ parseInt(t.css('borderTopWidth'), 10)			+ parseInt(t.css('borderBottomWidth'), 10);		// Calcul de la hauteur de la div		h = m - o - t.offset().top;		// Modification de la hauteur du composant		t.css('min-height', h + 'px');	})	// Elatic textareas (auto-height)	// Ce comportement qui ne s'applique qu'au champs TEXTAREA permet	// d'adapter la heuteur de la zone de texte en fonction de la quantitée	// de texte saisie par l'utilisateur.	.on('keydown', 'textarea.elastic', function () {		this.style.height = '';		this.rows = this.value.split('\n').length;		this.style.height = this.scrollHeight + 'px';	});};/** * Compatibilité des liens v2.X vers v3 : support de l'asynchrone. * * @param HTMLFormElement form * @param HTMLEvent event * @return boolean True si la lien a été traité en asynchrone * @access public static */WG.View.handleLink = function (href) {	// Check URL	if (href.substr(0, 1) == '?') {		href = 'index.php' + href;	}	else if (href.substr(0, 10) != 'index.php?') {		return false;	}	// Split URL tokens	var href = href.substr(10).split('&'),		view = null,		hash = null,		params = {},		i = 0,		j = href.length;	for (; i < j; i++) {		var token = href[i];		// Hash		if (token.indexOf('#') !== -1) {			hash = token.substr(token.indexOf('#') + 1, token.length);			token = token.substr(0, token.indexOf('#'));		}		// Split parameters		var value = token.split('='),			key = value.shift();		value = value.join();		// Save view		if (key == 'view') {			view = value;		}		// Save variable		else {			params[key] = unescape(value);		}	}	// La vue a été trouvée, on va pouvoir la demander correctement	if (view != null) {		WG.setView(view, params, false, hash);		return true;	}	// Sinon et bien on verra bien...	return false;};/** * Compatibilité des formulaires v2.x vers v3 : support de l'asynchrone. * * @param HTMLFormElement form * @param HTMLEvent event * @return boolean * @access public static */WG.View.handleForms = function (form, event) {	var t = $(form),		data = {};	// La première chose c'est de détecter les formulaires qui envoient	// des fichiers : ils auront un traitement spécial	if (t.hasAttr('enctype') && form.enctype == 'multipart/form-data') {		throw 'Not implemented yet';	}	// On recupère les valeurs de champs	$('input,textarea,select', form).each(function () {		var n = $(this);		if (n.hasAttr('name')) {			// @todo Ne pas envoyer les champs désactivés			// Un petit correctif pour le nom de la vue			if (n.attr('name') == 'view') {				data['v'] = n.val();			}			// Save field value			else {				data[this.name] = n.val();			}			// Disable field			n.attr('disabled', 'disabled');		}	});	// Debug	//for (field in data) console.log('  ' + field + ' = ' + data[field]);	// Update UI	WG.setStatus('Sending data...', WG.status.WAIT);	// Save current view	var view = WG.ui.currentView;	// On fait une requête ajax asynchrone	WG.ajax({		url: 'view.php',		data: data,		dataType: 'html',		success: function (data) {			// Update UI			WG.setStatus(null);			// Save loaded URL			if (console) {				console.log('Loaded URL: ' + view.getURL(data));			}			view.loadedUrl = view.getURL(data);			// Update contents			view.setContents(data);		},		error: function (jqXHR, textStatus, errorThrown) {			WG.setStatus(				'Unable to post this form: ' + errorThrown,				WG.status.FAILURE,				function () {					WG.setStatus(null);				},				'close'			);		}	});	// Prevent default behavior (stop submit process)	event.preventDefault();	return true;}WG.View.DistributionModel = {	/**	 * La page est rafraichie à chaque fois.	 */	REFRESH: 1,	/**	 * La page est rafraichie si la durée de vie du cache local a expiré.	 * C'est le model par défaut.	 */	LOCAL_CACHE: 2,	/**	 * La page est téléchargée une fois, ensuite le cache est utilisé systématiquement.	 * Soit la vue est statique, soit elle utilise le service live pour se mettre à jour.	 */	KEEP_ALIVE: 3,	/**	 * Le contenu de la page est envoyé au fur et à mesure.	 */	CONTINUE: 4};