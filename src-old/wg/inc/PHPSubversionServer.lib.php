<?php
/*
$Id: phpsubversionserver-1.0.5.php,v 1.0.5 2012/04/26 03:33:58 evolya Exp $

PHP Subversion Server

Copyright (c) 2012 evolya.fr

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

If you have any questions or comments, please email:

contact@evolya.fr
http://evolya.fr/
*/
define('PHPSUBVERSIONSERVER_VERSION', '1.0.5'); class SubversionFilesystemException extends Exception { }class SubversionServerException extends SubversionFilesystemException { }function file_get_all($dir, $recursive = true, $gitignore = true) {if ($gitignore === true) {$gitignore = array();}if ($handle = opendir($dir)) {$r = array();while (false !== ($entry = readdir($handle))) {$path = "$dir/$entry";if ($entry == '.' || $entry == '..') {continue;}if (is_array($gitignore)) {foreach ($gitignore as $rule) {if (fnmatch($rule, $entry)) {continue 2;}}}if (is_dir($path)) {$r[$path] = true;if ($recursive) {$files = file_get_all($path, $recursive, $gitignore);if (!is_array($files)) {return $path;}$r = array_merge($r, $files);}}else {$r[$path] = false;if (is_array($gitignore) && $entry == '.gitignore') {$fg = file_get_contents($path);if ($fg) {$fg = explode("\n", $fg);foreach ($fg as $fl) {$fl = trim($fl);if ($fl == '' || substr($fl, 0, 1) == '#') {continue;}$gitignore[] = $fl;}}unset($fg, $fl);}}}closedir($handle);return $r;}return $dir;}function cleanpath($path, $isdir=null) {if ($path === '.' || $path === '') {return '/';}$path = str_replace('\\', '/', $path);if (substr($path, 0, 2) === './') {$path = substr($path, 1);}if (substr($path, 0, 1) !== '/') {$path = '/' . $path;}while (strpos($path, '//') !== false) {$path = str_replace('//', '/', $path);}$path = str_replace(array('/../', '/./'), array('/', '/'), $path);if ($isdir === true && substr($path, -1) !== '/') {$path .= '/';}else if ($isdir === false && substr($path, -1) === '/') {return substr($path, 0, -1);}return $path;}function rrmdir($dir) {if (is_dir($dir)) {$entries = scandir($dir);foreach ($entries as $entry) {if ($entry !== '.' && $entry !== '..') {$entry = $dir . '/' . $entry;if (is_dir($entry)) {rrmdir($entry);}else {unlink($entry);}}}rmdir($dir);}}function stream2stream ($ifp, $ofp, $bufsize=8192) {while (!feof($ifp)) {if (fwrite($ofp, fread($ifp, $bufsize)) === false) {return false;}}return true;}  define('T_LAST',0);define('T_NOBODY',1);class ReturnCodeEnum {const E_OK= 1; const E_NOT_DIR= 2; const E_NOT_EXISTS= 3; const E_CANT_READ= 4; const E_CANT_WRITE= 5; const E_CANT_CREATE= 6; const E_ALLREADY_EXISTS= 7; const E_LOCKED= 8; const E_NOT_ALLOWED= 9; public static function nameOf($code) {switch ($code) {case self::E_OK : return 'E_OK';case self::E_NOT_DIR : return 'E_NOT_DIR';case self::E_NOT_EXISTS : return 'E_NOT_EXISTS';case self::E_CANT_WRITE : return 'E_CANT_WRITE';case self::E_CANT_CREATE : return 'E_CANT_CREATE';case self::E_ALLREADY_EXISTS : return 'E_ALLREADY_EXISTS';case self::E_LOCKED : return 'E_LOCKED';case self::E_NOT_ALLOWED : return 'E_NOT_ALLOWED';}return 'E_UNKNOWN';}public static function error_name($code) {return self::nameOf($code);}}class ACLAction {const R_DIRLIST= 0;const R_WRITE= 1;const R_READ= 2;const R_MKDIR= 3;const R_DELETE= 4;public static function nameOf($code) {switch ($code) {case self::R_DIRLIST : return 'R_DIRLIST';case self::R_WRITE : return 'R_WRITE';case self::R_READ : return 'R_READ';case self::R_MKDIR : return 'R_MKDIR';case self::R_DELETE : return 'R_DELETE';}return 'R_UNKNOWN';}}  interface SubversionFilesystem {public function acl();public function add_version($path, $username, $metaversion, $size, $ctime, $message);public function contents_changed($path, $version1, $version2);public function delete($path, $username=T_NOBODY, $message='', $removeMeta=true);public function file_diff($path, $version1, $version2);public function file_exists($path);public function file_get_contents($path, $username=T_NOBODY, $version=T_LAST);public function file_put_contents($path, $contents, $username=T_NOBODY, $message='');public function file_write_stream($path, $fp, $username=T_NOBODY, $message='');public function fileinfo($path, $version=T_LAST);public function filesize($path, $version=T_LAST);public function fopen($path, $mode, $version=T_LAST, $username=T_NOBODY);public function is_dir($path);public function is_file($path);public function last($path);public function lock($path, $username);public function locked($path);public function ls($path, $username=T_NOBODY);public function mkdir($path, $username=T_NOBODY, $message='', $recursive=true);public function revert($path, $version, $username=T_NOBODY, $message='');public function unlock($path, $username);public function update($path, $all=false, $demo=false);public function version($path, $version);public function versions($path);}interface SubversionServerACLManager {public function allow($action, $path, $username);}interface SubversionServerAuthManager {public function login($username, $password);public function username();}  class DefaultACLManager implements SubversionServerACLManager {public function allow($action, $path, $username) {return true;}}class DefaultAuthManager implements SubversionServerAuthManager {public function __construct() {if (session_id() == '') {session_start();}}public function login($username, $password) {$_SESSION['PHPSubversionServer_username'] = $username;return true;}public function username() {return isset($_SESSION['PHPSubversionServer_username']) ? $_SESSION['PHPSubversionServer_username'] : null;}}  class PHPSubversionFilesystem implements SubversionFilesystem {protected $rootDir;protected $metaDir;protected $aclMgr;protected $metaCache = array();protected $lockCache = array();public function __construct($rootDir, $metaDir, SubversionServerACLManager $aclMgr=null) {if (!is_dir($rootDir) || !is_readable($rootDir)) {throw new SubversionFilesystemException("Invalid root dir: $rootDir");}if (!is_dir($metaDir) || !is_readable($metaDir)) {throw new SubversionFilesystemException("Invalid meta dir: $metaDir");}if (!$aclMgr) {$aclMgr = new DefaultACLManager();}$this->rootDir = str_replace('\\', '/', realpath($rootDir)) . '/';$this->metaDir = str_replace('\\', '/', realpath($metaDir)) . '/';$this->aclMgr = $aclMgr;}public function acl() {return $this->aclMgr;}public function add_version($path, $username, $metaversion, $size, $ctime, $message) {$path = self::cleanpath($path);$metafile = $this->metaDir . $this->metafile($path) . '.m';if (!isset($this->metaCache[$path])) {if (is_file($metafile)) {$this->metaCache[$path] = unserialize(file_get_contents($metafile));if (!is_array($this->metaCache[$path])) {throw new SubversionFilesystemException("Unable to read meta file: $metafile");}}else {$this->metaCache[$path] = array();}}$meta = array('v' => sizeof($this->metaCache[$path]) + 1, 'd' => 'W', 'p' => $path, 'u' => $username, 'f' => $metaversion, 's' => $size, 'c' => $ctime, 'm' => $message );$this->metaCache[$path][] = $meta;if (file_put_contents($metafile, serialize($this->metaCache[$path])) === false) {throw new SubversionFilesystemException("Unable to write meta file: $metafile");}return $meta;}public function contents_changed($path, $version1, $version2) {$version1 = $this->file_get_contents($path, T_NOBODY, $version1); $version2 = $this->file_get_contents($path, T_NOBODY, $version2);if (!is_string($version1) || !is_string($version1)) {return false;}return md5($version1) === md5($version2);}public static function cleanpath($path, $isdir=null) {if ($path === '.' || $path === '') {return '/';}$path = str_replace('\\', '/', $path);if (substr($path, 0, 2) === './') {$path = substr($path, 1);}if (substr($path, 0, 1) !== '/') {$path = '/' . $path;}while (strpos($path, '//') !== false) {$path = str_replace('//', '/', $path);}$path = str_replace(array('/../', '/./'), array('/', '/'), $path);if ($isdir === true && substr($path, -1) !== '/') {$path .= '/';}else if ($isdir === false && substr($path, -1) === '/') {return substr($path, 0, -1);}return $path;}public function delete($path, $username=T_NOBODY, $message='', $removeMeta=false) {$path = self::cleanpath($path);$rpath = $this->rootDir . $path;if (is_file($rpath)) {unlink($rpath);}if (is_dir($rpath)) {if ($handle = opendir($rpath)) {while (false !== ($entry = readdir($handle))) {if ($entry !== '.' && $entry !== '..') {$this->delete($rpath, $username, $message, $removeMeta);}}closedir($handle);}}if ($removeMeta) {$versions = $this->versions($path);if (is_array($versions)) {foreach ($versions as $v) {unlink($this->metaDir . $v['f']);}}unlink($this->metaDir . $this->metafile($path) . '.m');unset($this->metaCache[$path]);}return ReturnCodeEnum::E_OK;}public function file_diff($path, $version1, $version2) {if (!class_exists('Text_Diff')) {throw new SubversionFilesystemException('Package PEAR::Text_Diff missing');}$version1 = $this->file_get_contents($path, T_NOBODY, $version1); $version2 = $this->file_get_contents($path, T_NOBODY, $version2);if (!is_string($version1) || !is_string($version2)) {return null;}$version1 = explode("\n", $version1);$version2 = explode("\n", $version2);$diff = new Text_Diff('auto', array($version1, $version2));return $diff->getDiff();}public function file_exists($path) {return file_exists($this->rootDir . self::cleanpath($path, true));}public function file_get_contents($path, $username=T_NOBODY, $version=T_LAST) {$path = self::cleanpath($path);$path = self::test_file_opt($path, $username, ACLAction::R_READ);if (!is_string($path)) {return $path;}$rpath = $this->rootDir . $path;if ($version === T_LAST) {if (!file_exists($rpath)) {return ReturnCodeEnum::E_NOT_EXISTS;}return file_get_contents($rpath);}$version = $this->version($path, $version);if (!$version) {return ReturnCodeEnum::E_NOT_EXISTS;}$metafile = $this->metaDir . $version['f'];if (!is_file($metafile) || !is_readable($metafile)) {throw new SubversionFilesystemException("Unable to read meta file: $metafile");}return file_get_contents($metafile);}public function file_put_contents($path, $contents, $username=T_NOBODY, $message='') {$path = self::cleanpath($path);$path = self::test_file_opt($path, $username, ACLAction::R_WRITE);if (!is_string($path)) {return $path;}$rpath = $this->rootDir . $path;$metaversion = $this->metafile($path) . '-' . time() . '-' . rand(1000000000, 9999999999) . '.d';if (file_put_contents($this->metaDir . $metaversion, $contents) === false) {throw new SubversionFilesystemException("Unable to write meta file: {$this->metaDir}{$metaversion}");}if (!copy($this->metaDir . $metaversion, $rpath)) {unlink($this->metaDir . $metaversion);return ReturnCodeEnum::E_CANT_WRITE;}$this->add_version($path, $username, $metaversion, strlen($contents), time(), $message);return ReturnCodeEnum::E_OK;}public function file_write_stream($path, $fp, $username=T_NOBODY, $message='') {$path = self::cleanpath($path);$path = self::test_file_opt($path, $username, ACLAction::R_WRITE);if (!is_string($path)) {return $path;}$rpath = $this->rootDir . $path;$metaversion = $this->metafile($path) . '-' . time() . '-' . rand(1000000000, 9999999999) . '.d';$ofp = fopen($this->metaDir . $metaversion, 'w');if (!$ofp) {throw new SubversionFilesystemException("Unable to create meta file: {$this->metaDir}{$metaversion}");}if (!stream2stream($fp, $ofp, 256000)) {throw new SubversionFilesystemException("Unable to write meta file: {$this->metaDir}{$metaversion}");}fclose($ofp);if (!copy($this->metaDir . $metaversion, $rpath)) {unlink($this->metaDir . $metaversion);return ReturnCodeEnum::E_CANT_WRITE;}$this->add_version($path, $username, $metaversion, filesize($rpath), time(), $message);return ReturnCodeEnum::E_OK;}public function fileinfo($path, $version=T_LAST) {$path = $this->realpath($path, $version);if (is_string($path) && is_file($rpath)) {return array('path' => $path,'size' => filesize($rpath),'ctime' => filectime($rpath),'mctime' => filemtime($rpath),'actime' => fileatime($rpath));}return null;}public function filesize($path, $version=T_LAST) {$path = $this->realpath($path, $version);if (is_string($path) && is_file($rpath)) {return filesize($rpath);}return false;}public function fopen($path, $mode, $version=T_LAST, $username=T_NOBODY) {throw new Exception('Not implemented yet!');}public function is_dir($path) {return is_dir($this->rootDir . self::cleanpath($path, true));}public function is_file($path) {return is_file($this->rootDir . self::cleanpath($path, false));}public function last($path) {$versions = $this->versions(self::cleanpath($path));if (!is_array($versions)) {return null;}return array_pop($versions);}public function lock($path, $username) {$this->lockCache[self::cleanpath($path)] = $username;}public function locked($path) {return isset($this->lockCache[self::cleanpath($path)]);}public function ls($path, $username=T_NOBODY) {$path = self::cleanpath($path);$path = self::test_dir_opt($path, $username, ACLAction::R_DIRLIST);if (!is_string($path)) {return $path;}$rpath = $this->rootDir . $path;$r = array();if ($handle = opendir($rpath)) {while (false !== ($entry = readdir($handle))) {if ($entry !== '.' && $entry !== '..') {$r[$entry] = is_dir("$rpath/$entry");}}closedir($handle);}return $r;}protected function metafile($path) {return sha1($path);}public function mkdir($path, $username=T_NOBODY, $message='', $recursive=true) {$npath = self::cleanpath($path, true);$rpath = $this->rootDir . $npath;if (substr($rpath, 0, strlen($this->rootDir)) !== $this->rootDir) {return ReturnCodeEnum::E_NOT_EXISTS;}if ($username !== T_NOBODY) {if (!$this->aclMgr->allow(ACLAction::R_MKDIR, $npath, $username)) {return ReturnCodeEnum::E_NOT_ALLOWED;}}if ($this->locked($npath)) {return ReturnCodeEnum::E_LOCKED;}if (is_dir($rpath)) {return ReturnCodeEnum::E_ALLREADY_EXISTS;}if (mkdir($rpath, 0, $recursive) !== true) {return ReturnCodeEnum::E_CANT_CREATE;}else {return ReturnCodeEnum::E_OK;}}protected function realpath($path, $version=T_LAST) {$path = self::cleanpath($path);if ($version === T_LAST) {return $this->rootDir . $path;}$version = $this->version($path, $version);if (is_array($version)) {return $this->metaDir . $version['f'];}return null;}public function revert($path, $version, $username=T_NOBODY, $message='') {$path = self::cleanpath($path);$version = $this->version($path, $version);if (!is_array($version)) {return ReturnCodeEnum::E_NOT_EXISTS;}if ($username !== T_NOBODY) {if (!$this->aclMgr->allow(ACLAction::R_WRITE, $path, $username)) {return ReturnCodeEnum::E_NOT_ALLOWED;}}$metafile = $this->metaDir . $version['f'];if (!is_file($metafile) || !is_readable($metafile)) {throw new SubversionFilesystemException("Unable to read meta file: $metafile");}file_put_contents($this->rootDir . $path,file_get_contents($metafile));$metaversion = $this->metafile($path) . '-' . time() . '-' . rand(1000000000, 9999999999) . '.d';$this->add_version($path,$username,$metaversion,$version['s'],$version['c'],'Revert: ' . $message);return ReturnCodeEnum::E_OK;}protected function test_dir_opt($path, $username, $action) {$rpath = $this->rootDir . $path;if (!is_dir($rpath)) {return ReturnCodeEnum::E_NOT_DIR;}$rpath = str_replace('\\', '/', realpath($rpath)) . '/';if (substr($rpath, 0, strlen($this->rootDir)) !== $this->rootDir) {return ReturnCodeEnum::E_NOT_EXISTS;}$path = str_replace('\\', '/', '/' . substr($rpath, strlen($this->rootDir)));if ($username !== T_NOBODY) {if (!$this->aclMgr->allow($action, $path, $username)) {return ReturnCodeEnum::E_NOT_ALLOWED;}}if ($this->locked($path)) {return ReturnCodeEnum::E_LOCKED;}return $path;}protected function test_file_opt($path, $username, $action) {$rpath = $this->rootDir . $path;$dpath = dirname($rpath);if (!is_dir(dirname($dpath))) {return ReturnCodeEnum::E_NOT_DIR;}$dpath = str_replace('\\', '/', realpath($dpath)) . '/';if (substr($dpath, 0, strlen($this->rootDir)) !== $this->rootDir) {return ReturnCodeEnum::E_NOT_EXISTS;}$path = str_replace('\\', '/', substr($rpath, strlen($this->rootDir)));if ($username !== T_NOBODY) {if (!$this->aclMgr->allow($action, $path, $username)) {return ReturnCodeEnum::E_NOT_ALLOWED;}}if (is_dir($rpath)) {return ReturnCodeEnum::E_ALLREADY_EXISTS;}if ($this->locked($path)) {return ReturnCodeEnum::E_LOCKED;}return $path;}public function unidiff($path, $version1, $version2) {$diff = $this->diff($path, $version1, $version2);if (!is_array($diff)) {return null;}$l1 = 1;$l2 = 1;$r = array();foreach ($diff as $d) {$s1 = '0';$s2 = '0';switch (get_class($d)) {case 'Text_Diff_Op_copy' :$s1 = $s2 = sizeof($d->final);$l1 += $s1;$l2 += $s2;$out = "\n " . implode("\n ", $d->final);break;case 'Text_Diff_Op_add' :$out = "\n+" . implode("\n+", $d->final);$s2 = sizeof($d->final);$l2 += $s2;break;case 'Text_Diff_Op_change' :$out = "\n-" . implode("\n-", $d->orig);$s1 = sizeof($d->orig);$l1 += $s1;$out .= "\n+" . implode("\n+", $d->final);$s2 = sizeof($d->final);$l2 += $s2;break;case 'Text_Diff_Op_delete' :$out = "\n-" . implode("\n-", $d->orig);$s1 = sizeof($d->orig);$l1 += $s1;}$r[] = "\n@@ -$l1,$s1 +$l2,$s2 @@$out";}return implode('', $r);}public function unlock($path, $username) {unset($this->lockCache[self::cleanpath($path)]);}public function update($path, $all=false, $demo=false) {$path = self::cleanpath($path, true);$rpath = $this->rootDir . $path;if (!is_dir($rpath)) {return ReturnCodeEnum::E_NOT_DIR;}if ($handle = opendir($rpath)) {$r = array();while (false !== ($entry = readdir($handle))) {if ($entry === '.' || $entry === '..') continue;$fpath = "$rpath/$entry";if (is_dir($fpath)) {$tmp = $this->update("$path/$entry", $all, $demo);if (!is_array($tmp)) {return $tmp;}$r = array_merge($r, $tmp);}else {$pathname = "$path$entry";$size = filesize($fpath);$time = filemtime($fpath);$version = $this->last($pathname);if (($version == null && $all) || ($version != null && ($version['s'] !== $size || $version['c'] !== $time))) {$r[] = "$pathname";if (!$demo) {$metaversion = $this->metafile($pathname) . '-' . time() . '-' . rand(1000000000, 9999999999) . '.d';if (copy($fpath, $this->metaDir . $metaversion) !== true) {throw new SubversionFilesystemException("Unable to copy: {$pathname} --> {$this->metaDir}{$metaversion}");}$this->add_version($pathname, T_NOBODY, $metaversion, $size, $time, 'update');}}}}closedir($handle);return $r;}return ReturnCodeEnum::E_CANT_READ;}public function version($path, $version) {$versions = $this->versions($path);if (is_array($versions)) {foreach ($versions as $v) {if ($v['v'] === $version) return $v;}}return null;}public function versions($path) {$path= self::cleanpath($path, false);$rpath = $this->rootDir . $path;if (isset($this->metaCache[$path])) {return $this->metaCache[$path];}$metafile = $this->metaDir . $this->metafile($path) . '.m';if (is_file($metafile)) {$tmp = unserialize(file_get_contents($metafile));if (!is_array($tmp)) {throw new SubversionFilesystemException("Unable to read meta file: $metafile");}$this->metaCache[$path] = $tmp;return $tmp;}else if (file_exists($rpath)) {echo "yoyo";return false;$metaversion = $this->metafile($path) . '-' . time() . '-' . rand(1000000000, 9999999999) . '.d';if (copy($rpath, $this->metaDir . $metaversion) !== true) {throw new SubversionFilesystemException("Unable to copy: {$rpath} --> {$this->metaDir}{$metaversion}");}return array($this->add_version($path, T_NOBODY, $metaversion, filesize($rpath), filemtime($rpath), 'resynch'));}return false;}}  class PHPSubversionServer extends PHPSubversionFilesystem {protected $authMgr;public function __construct($rootDir, $metaDir, SubversionServerACLManager $aclMgr=null, SubversionServerAuthManager $authMgr=null) {parent::__construct($rootDir, $metaDir, $aclMgr);if (!$authMgr) {$authMgr = new DefaultAuthManager();}$this->authMgr = $authMgr;}public function handleRequest() {header('Content-type: application/json; charset=utf-8');if (!isset($_REQUEST['cmd'])) {$this->error('Missing Command Name', 400);return;}if ($_REQUEST['cmd'] === 'login') {if (!isset($_REQUEST['username']) || !isset($_REQUEST['password'])) {$this->error('Bad Request [1]', 400);}else {$this->handle_login($_REQUEST['username'], $_REQUEST['password']);}return;}if ($this->authMgr->username() === null) {$this->error('Unauthorized [0]', 401);return;}$cmd = 'handle_' . $_REQUEST['cmd'];if (method_exists($this, $cmd)) {$this->$cmd();return;}$this->error('Command Not Found', 404);}protected function handle_login($username, $password) {if ($this->authMgr->login($username, $password)) {echo json_encode(array('username' => $username, 'time' => $_SERVER['REQUEST_TIME']));return true;}$this->error('Forbidden', 403);return false;}protected function handle_ls() {if (!isset($_REQUEST['path'])) {$this->error('Bad Request', 400);return false;}$ls = $this->ls($_REQUEST['path'], $this->authMgr->username());if (is_array($ls)) {echo json_encode(array_keys($ls));return true;}$this->error(ReturnCodeEnum::nameOf($ls), 500);return false;}protected function handle_file_get_contents() {if (!isset($_REQUEST['path'])) {$this->error('Bad Request', 400);return false;}$version = (isset($_REQUEST['version']) ? intval($_REQUEST['version']) : T_LAST);$ct = $this->file_get_contents($_REQUEST['path'], $this->authMgr->username(), $version);if (is_string($ct)) {header('Content-type: application/octet-stream');echo $ct;return true;}switch ($ct) {case ReturnCodeEnum::E_LOCKED :$this->error('Conflict', 409);break;case ReturnCodeEnum::E_NOT_ALLOWED :$this->error('Forbidden', 403);break;default :$this->error('Not Found ('.ReturnCodeEnum::nameOf($ct).')', 404);break;}return false;}protected function error($msg, $code=-1) {if ($code !== -1) {header("HTTP/1.0 $code $msg", true, $code);}header('Content-type: application/json; charset=utf-8', true);echo json_encode(array('error' => $msg));}}  class PHPSubversionClient {public $url;public $cookiefile;public $debug = false;public function __construct($url, $cookiefile) {$this->url = $url;$this->cookiefile = $cookiefile;}public function login($success=null, $failure=null, $username, $password) {return $this->request(array('cmd' => 'login', 'username' => $username, 'password' => $password),$success,$failure);}protected function download($filename, $params, $success=null, $failure=null, $url=null, $progress=null, $bufferSize=2048) {if (!$url) {$url = $this->url;}$fp = fopen($filename, 'w+');if (!$fp) {throw new SubversionServerException('Unable to open: ' . $filename);}$ch = curl_init();curl_setopt($ch, CURLOPT_URL,$url);curl_setopt($ch, CURLOPT_HEADER,0);curl_setopt($ch, CURLOPT_POST,1);curl_setopt($ch, CURLOPT_FOLLOWLOCATION,1);curl_setopt($ch, CURLOPT_RETURNTRANSFER,0);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER,0);curl_setopt($ch, CURLOPT_TIMEOUT,50);curl_setopt($ch, CURLOPT_FILE,$fp);curl_setopt($ch, CURLOPT_COOKIEJAR,$this->cookiefile);curl_setopt($ch, CURLOPT_COOKIEFILE,$this->cookiefile);curl_setopt($ch, CURLOPT_USERAGENT,'SoHo.Plug v3.0');curl_setopt($ch, CURLOPT_POSTFIELDS,$params);if ($progress !== null) {curl_setopt($ch, CURLOPT_NOPROGRESS, false);curl_setopt($ch, CURLOPT_PROGRESSFUNCTION, $progress);curl_setopt($ch, CURLOPT_BUFFERSIZE, $bufferSize);}set_time_limit(0);$data = curl_exec($ch);$code = curl_getinfo($ch, CURLINFO_HTTP_CODE);$statut = curl_errno($ch);$error = curl_error($ch);curl_close($ch);fclose($fp);if ($code !== 200 || $statut !== 0) {if ($failure) {return $failure($code, $error, $statut, null) === true ? true : false;}return false;}if ($success) {return $success($filename, $code) === false ? false : true;}return true;}protected function request($params, $success=null, $failure=null, $url=null, $progress=null, $bufferSize=2048) {if (!$url) {$url = $this->url;}if ($this->debug) {echo "[SubversionClient] Request for $url";foreach ($params as $k => $v) {echo "&$k=$v";}echo "\n";}$ch = curl_init();curl_setopt($ch, CURLOPT_URL,$url);curl_setopt($ch, CURLOPT_HEADER,0);curl_setopt($ch, CURLOPT_POST,1);curl_setopt($ch, CURLOPT_FOLLOWLOCATION,1);curl_setopt($ch, CURLOPT_RETURNTRANSFER,1);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER,0);curl_setopt($ch, CURLOPT_COOKIEJAR,$this->cookiefile);curl_setopt($ch, CURLOPT_COOKIEFILE,$this->cookiefile);curl_setopt($ch, CURLOPT_USERAGENT,'SoHo.Plug v3.0');curl_setopt($ch, CURLOPT_POSTFIELDS,$params);if ($progress !== null) {curl_setopt($ch, CURLOPT_NOPROGRESS, false);curl_setopt($ch, CURLOPT_PROGRESSFUNCTION, $progress);curl_setopt($ch, CURLOPT_BUFFERSIZE, $bufferSize);}set_time_limit(0);$data = curl_exec($ch);$code = curl_getinfo($ch, CURLINFO_HTTP_CODE);$statut = curl_errno($ch);$error = curl_error($ch);$type = curl_getinfo($ch, CURLINFO_CONTENT_TYPE);if (is_string($type)) {$type = array_shift(explode(';', $type));}else {$type = 'text/plain';}curl_close($ch);if ($code !== 200 || $statut !== 0) {if ($failure) {if ($type === 'application/json') {$tmp = @json_decode($data);if ($tmp === null) {$error = 'invalid json error';}else {if (@isset($tmp->error)) {$error = $tmp->error;}$data = $tmp;}}unset($tmp);return $failure($code, $error, $statut, $data) === true ? true : false;}return false;}if ($success) {if ($type === 'application/json') {$tmp = @json_decode($data);if ($tmp === null) {if ($failure) {return $failure($code, 'invalid json', 'success', $data) === true ? true : false;}return false;}else {$data = $tmp;}unset($tmp);}return $success($data, $code) === false ? false : true;}return true;}public function __call($name, $args) {if (method_exists($this, $name)) {return call_user_func_array(array($this, $name), $args);}throw new SubversionServerException('Unsupported method: ' . $name);}public function ls($success, $failure, $path) {return $this->request(array('cmd' => 'ls', 'path' => $path),$success,$failure);}public function file_get_contents($success, $failure, $path) {return $this->request(array('cmd' => 'file_get_contents', 'path' => $path),$success,$failure);}public function file_put_contents($success, $failure, $path, $contents) {return $this->request(array('cmd' => 'file_put_contents', 'path' => $path, 'contents' => $contents),$success,$failure);}public function delete($success, $failure, $path) {}public function mkdir($success, $failure, $path) {}}   ?>