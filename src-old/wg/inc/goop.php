<?php /*
$Id: goop-1.0.0.php,v 1.0.0 2012/04/13 23:02:13 evolya Exp $

Goop - Web Application Framework

Copyright (c) 2012 evolya.fr

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

If you have any questions or comments, please email:

contact@evolya.fr
http://evolya.fr/
*/ define('GOOP_VERSION', '1.0.0'); final class a extends GoopAPI {private static $b = array('app_url', 'lib_dir', 'db_host', 'db_user', 'db_pwd', 'db_name');private $c = array();public function __construct($d, $e) {$this->properties['goop_dir'] = array(dirname(__FILE__) . DIRECTORY_SEPARATOR, 'protected', 'goop');$this->properties['start_dir'] = array($e . DIRECTORY_SEPARATOR, 'protected', 'goop');foreach ($d as $f => $g) {switch ($f) {case 'public': case 'protected' : case 'private' :$this->h($f, $g);break;default:throw new GoopException('Invalid visibility in WAM file (near "'.$f.'": '.substr(json_encode($g), 0, 50).'...)');}}foreach (self::$b as $i) {if (!isset($this->properties[$i])) {throw new GoopException("Property '$i' is required; add it in your WAM configuration file.");}}}private function j($k) {foreach ($this->properties as $l => $data) {$k = str_replace("{\$$l}", $data[0], $k);}return $k;}private function h($f, $g) {foreach ($g as $l => $m) {$this->properties[$l] = array($this->j($m), $f, 'goop' );}}public function n($l) {return isset($this->properties[$l]);}public function get($l) {if (!isset($this->properties[$l])) {return null;}list($m, $o, $p) = $this->properties[$l];return $m;}} class q extends GoopAPI {private $r = array('*' => array());private $s = array();private $t;public function __construct() {$this->error = $this->goop()->api('error');}public function bind($u, $v, $w=false) {if (!is_string($u)) {return false;}$x = y();unset($x['object']);if ($v instanceof Closure || $v instanceof GoopCallback) {$u = trim(strtolower($u));if (!isset($this->r[$u])) {$this->r[$u] = array();}$this->r[$u][] = array('o' => (boolean) $w,'c' => $v,'s' => $x);}return $this;}public function one($u, $v) {return $this->bind($u, $v, true);}public function unbind() {throw new Exception('Unsupported operation: not implemented yet!');return $this;}public function trigger($u, $data=null) {if (!is_string($u)) {return false;}$u = trim(strtolower($u));$z = new GoopEventObject($u, $data);$x = y();unset($x['object']);$z->set('trigger_call', $x);$this->ba($z, $u, $u);$this->ba($z, '*', $u);$this->s[$u] = true;return $this;}private function ba($bb, $bc, $u) {if (!isset($this->r[$bc])) {return;}foreach ($this->r[$bc] as $bd) {if ($bb->isPropagationStopped()) {break;}try {$v = $bd['c'];if ($v instanceof Closure) {$v($bb);}else {$v->notify($bb);}}catch (Exception $be) {$this->error->bf($u, $bd['s'], $be);}}}}interface GoopCallback {public function notify(GoopEventObject $bg);}final class GoopEventObject {private $u;private $data = array();private $bh = false;private $bi = false;public function __construct($u, $data = null) {$this->eventName = $u;if (is_array($data)) {$this->data = $data;}}public function eventName() {return $this->eventName;}public function stopPropagation() {$this->bh = true;}public function isPropagationStopped() {return $this->bh;}public function preventDefault() {$this->bi = true;}public function isDefaultPrevented() {return $this->bi;}public function __get($l) {return $this->get($l);}public function __set($l, $m) {return $this->set($l, $m);}public function setArray($bj) {if (is_array($bj)) {$this->data = array_merge($this->data, $bj);}return $this;}public function get($l) {return isset($this->data[$l]) ? $this->data[$l] : null;}public function set($l, $m) {$this->data[$l] = $m;}public function properties() {return array_keys($this->data);}public function data() {return $this->data;}public function __toString() {return $this->eventName;}} final class bk extends GoopAPI {public function l() {return 'cache';}} final class bl extends GoopAPI {public function l() {return 'models';}} final class bm extends GoopAPI {public function __construct() {set_error_handler(array($this, 'handle'), E_ALL);}public function handle($bn, $bo, $bp, $bq, $br) {$this->goop()->events->trigger('error', array('error_call' => array('file' => $bp,'line' => $bq,'class' => '','type' => '','function' => '','args' => ''),'error_info' => array('errno' => $bn,'errstr' => $bo,'errfile' => $bp,'errline' => $bq,'errcontext' => $br)));}public function l() {return 'error';}public function bf($u, $x, Exception $be) {if ($u != 'error' && $u != 'exception') {$this->goop()->events->trigger('exception', array('exception' => $be));}}public static function bs($bt) {switch ($bt) {case JSON_ERROR_DEPTH: return 'JSON_ERROR_DEPTH';case JSON_ERROR_STATE_MISMATCH: return 'JSON_ERROR_STATE_MISMATCH';case JSON_ERROR_CTRL_CHAR: return 'JSON_ERROR_CTRL_CHAR';case JSON_ERROR_SYNTAX: return 'JSON_ERROR_SYNTAX';case JSON_ERROR_UTF8: return 'JSON_ERROR_UTF8';default: return 'JSON_ERROR_UNKNOWN';}}public static function bu($l) {switch ($l) {case 'JSON_ERROR_DEPTH': return JSON_ERROR_DEPTH;case 'JSON_ERROR_STATE_MISMATCH': return JSON_ERROR_STATE_MISMATCH;case 'JSON_ERROR_CTRL_CHAR': return JSON_ERROR_CTRL_CHAR;case 'JSON_ERROR_SYNTAX': return JSON_ERROR_SYNTAX;case 'JSON_ERROR_UTF8': return JSON_ERROR_UTF8;default: return bv;}}public static function bw($bt) {switch ($bt) {case JSON_ERROR_DEPTH: return 'The maximum stack depth has been exceeded';case JSON_ERROR_STATE_MISMATCH: return 'Invalid or malformed JSON';case JSON_ERROR_CTRL_CHAR: return 'Control character error, possibly incorrectly encoded';case JSON_ERROR_SYNTAX: return 'Syntax error';case JSON_ERROR_UTF8: return 'Malformed UTF-8 characters, possibly incorrectly encoded';default: return 'Unknown JSON error';}}public static function json_last_error() {return self::bw(json_last_error());}public static function bx($bt) {switch ($bt) {case E_ERROR: return 'E_ERROR';case E_WARNING: return 'E_WARNING';case E_PARSE: return 'E_PARSE';case E_NOTICE: return 'E_NOTICE';case E_CORE_ERROR: return 'E_CORE_ERROR';case E_CORE_WARNING: return 'E_CORE_WARNING';case E_COMPILE_ERROR: return 'E_COMPILE_ERROR';case E_COMPILE_WARNING: return 'E_COMPILE_WARNING';case E_USER_ERROR: return 'E_USER_ERROR';case E_USER_WARNING: return 'E_USER_WARNING';case E_USER_NOTICE: return 'E_USER_NOTICE';case E_STRICT: return 'E_STRICT';case E_ALL: return 'E_ALL';default: return 'E_ERROR_UNKNOWN';}}public static function by($l) {switch ($l) {case 'E_ERROR': return E_ERROR;case 'E_WARNING': return E_WARNING;case 'E_PARSE': return E_PARSE;case 'E_NOTICE': return E_NOTICE;case 'E_CORE_ERROR': return E_CORE_ERROR;case 'E_CORE_WARNING': return E_CORE_WARNING;case 'E_COMPILE_ERROR': return E_COMPILE_ERROR;case 'E_COMPILE_WARNING': return E_COMPILE_WARNING;case 'E_USER_ERROR': return E_USER_ERROR;case 'E_USER_WARNING': return E_USER_WARNING;case 'E_USER_NOTICE': return E_USER_NOTICE;case 'E_STRICT': return E_STRICT;case 'E_ALL': return E_ALL;default: return -1;}}public static function bz($bt) {switch ($bt) {case E_ERROR: return 'Fatal run-time errors. These indicate errors that can not be recovered from, such as a memory allocation problem. Execution of the script is halted';case E_WARNING: return 'Run-time warnings (non-fatal errors). Execution of the script is not halted';case E_PARSE: return 'Compile-time parse errors. Parse errors should only be generated by the parser';case E_NOTICE: return 'Run-time notices. Indicate that the script encountered something that could indicate an error, but could also happen in the normal course of running a script';case E_CORE_ERROR: return 'Fatal errors that occur during PHP\'s initial startup. This is like an E_ERROR, except it is generated by the core of PHP';case E_CORE_WARNING: return 'Warnings (non-fatal errors) that occur during PHP\'s initial startup. This is like an E_WARNING, except it is generated by the core of PHP';case E_COMPILE_ERROR: return 'Fatal compile-time errors. This is like an E_ERROR, except it is generated by the Zend Scripting Engine';case E_COMPILE_WARNING: return 'Compile-time warnings (non-fatal errors). This is like an E_WARNING, except it is generated by the Zend Scripting Engine';case E_USER_ERROR: return 'User-generated error message. This is like an E_ERROR, except it is generated in PHP code by using the PHP function trigger_error()';case E_USER_WARNING: return 'User-generated warning message. This is like an E_WARNING, except it is generated in PHP code by using the PHP function trigger_error()';case E_USER_NOTICE: return 'User-generated notice message. This is like an E_NOTICE, except it is generated in PHP code by using the PHP function trigger_error()';case E_STRICT: return 'Enable to have PHP suggest changes to your code which will ensure the best interoperability and forward compatibility of your code';case E_ALL: return 'All errors and warnings, as supported, except of level E_STRICT prior to PHP 5.4.0';default: return 'Unknown PHP error';}}}class GoopException extends Exception { } class ca extends GoopAPI {public function __construct() {}} final class Goop {private static $cb = null;private static $cc;private $api = array();private $cd = array();private function __construct() {}public static function build() {if (self::$cb != null) {return self::$cb;}self::$cc = microtime(true);$ce = new Goop();self::$cb = $ce;$GLOBALS['goop'] = $ce;$ce->api['error'] = new bm();$ce->api['events'] = new q();self::$cc = microtime(true) - self::$cc;return $ce;}public function __get($l) {return isset($this->api[$l]) ? $this->api[$l] : null;}public function api($l) {return isset($this->api[$l]) ? $this->api[$l] : null;}public function loadWAM($cf) {if (!is_file($cf)) {throw new GoopException('WAM file not found: ' . $cf);}if (!is_readable($cf)) {throw new GoopException('WAM file not readable: ' . $cf);}$cf = realpath($cf);$data = file_get_contents($cf);if (!$data) {throw new GoopException('Unable to read WAM file: ' . $cf);}$data = json_decode($data, true);if (!is_array($data)) {throw new GoopException('Invalid JSON in WAM file: ' . $cf . ' (' . bm::json_last_error() . ')');}$cg = isset($ch['SERVER_NAME']) ? $ch['SERVER_NAME'] : 'localhost';if (!isset($data[$cg])) {throw new GoopException('Host not supported: ' . $cg);}$d = $data[$cg];if (isset($d['import'])) {if (!isset($data[$d['import']])) {throw new GoopException('Host not found: ' . $d['import']);}$d = $data[$d['import']];}$x = y();$this->api['config'] = new a($d, dirname($x['file']));if (isset($this->config->error_reporting)) {if (bm::by($this->config->error_reporting) != -1) {error_reporting(bm::by($this->config->error_reporting));$this->api('events')->trigger('errorlevelchange', array('level' => error_reporting()));}else if (intval($this->config->error_reporting) . '' == $this->config->error_reporting) {error_reporting(intval($this->config->error_reporting));$this->api('events')->trigger('errorlevelchange', array('level' => error_reporting()));}}if (isset($this->config->ci)) {date_default_timezone_set($this->config->ci);ini_set('date.timezone', $this->config->ci);$this->api('events')->trigger('timezonechange', array('timezone' => $this->config->ci));}ignore_user_abort(true);set_time_limit(0);@set_magic_quotes_runtime(false);ini_set('magic_quotes_runtime', 0);if (get_magic_quotes_gpc()) {if (!function_exists('stripslashes_deep')) {function & cj(&$m) {if (is_array($m)) {$m = array_map('stripslashes_deep', $m);}else if (is_string($m)) {$m = stripslashes($m);}return $m;}}global $ck, $cl, $cm, $cn, $co, $cp;cj($ck);cj($cl);cj($cm);cj($cn);cj($co);cj($cp);}$this->api['events']->trigger('wamloaded', array('filename' => $cf));if ($this->config->n('modules_dir')) {$cq = $this->config->get('modules_dir');$cd = scandir($cq, 1);if (!is_array($cd)) {throw new GoopException("Error in module autoload: unable to scan dir ($cq)");}foreach ($cd as $cr) {if ($cr === '.' || $cr === '..') continue;if (substr($cr, 0, 1) === '_') continue;$this->cs("$cq/$cr/module.json");}}}private function cs($cf) {if (!is_file($cf) || !is_readable($cf)) {throw new GoopException("Error in module autoload: manifest file not found ($cf)");}$d = file_get_contents($cf);if (!$d) {throw new GoopException("Error in module autoload: unable to read file ($cf)");}$d = json_decode($d, true);if (!is_array($d)) {throw new GoopException('Invalid JSON in module manifest: ' . $cf . ' (' . bm::json_last_error() . ')');}if (!isset($d['moduleName'])) {throw new GoopException('Invalid module manifest: property "moduleName" not found');}if (isset($this->cd[$d['moduleName']])) {throw new GoopException("Module allready exists: {$d['moduleName']} (in $cf)");}$this->cd[$d['moduleName']] = $d;$this->api['events']->trigger('moduleloaded', array('name' => $d['moduleName'],'manifest' => $cf));}public function require_lib($cf='') {global $goop;require_once $this->api['config']->get('lib_dir') . '/' . $cf;}public function installAPI($ct, GoopAPI $api) {if (isset($this->api[$ct])) {throw new GoopException('API allready exists: ' . $ct);}$this->api[$ct] = $api;}public function property($l) {return $this->api['config']->get($l);}}abstract class GoopAPI {public function goop() {return Goop::build();}}if (!function_exists('whoCalledMe')) {function y($cu=0) {$cv = debug_backtrace();if (sizeof($cv) > 2) {$cw = @$cv[2 + $cu];if (!is_array($cw)) {return false;}if (array_key_exists('file', @$cv[1 + $cu])) {$cw['file'] = @$cv[1 + $cu]['file'];}if (array_key_exists('line', @$cv[1 + $cu])) {$cw['line'] = @$cv[1 + $cu]['line'];}return $cw;}else {return @$cv[1];}}}Goop::build();  ?>